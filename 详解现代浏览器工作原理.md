# 详解现代浏览器的工作原理

**转载或引用本文文段请注明出处：[https://github.com/Ciya-Huang/Blog-posts-by-Ciya/blob/master/详解现代浏览器的工作原理.md](https://github.com/Ciya-Huang/Blog-posts-by-Ciya/blob/master/详解现代浏览器的工作原理.md)。**

了解浏览器的工作原理能帮助Web开发者更好地理解怎样写出性能更优的代码，本文译自一篇经典文章来入门这一块的知识——[How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)。

本文系Ciya对原文翻译并再加工的结果，对原文不甚详细的地方添加了相关知识或解析，并修订了一些用词等其他细节使之更加通俗/本地化，希望能给大家更好的阅读体验。你也可以点击[这里](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)阅读另一中文译文。

PS：Ciya额外添加的内容会以 （**注：……**） 的形式标记在文中。

不足之处，还请各位同胞多多指点。(〃'▽'〃)
  
<!-- TOC -->

**[目录]()**  

[0 序言](#0-序言)  
[1 浏览器简介](#1-浏览器简介)
  - [1.1 本文会讨论到的浏览器](#11-本文会讨论到的浏览器)
  - [1.2 浏览器的主要功能](#12-浏览器的主要功能)
  - [1.3 浏览器的高层结构](#13-浏览器的高层结构)  

[2 渲染引擎及渲染主流程](#2-渲染引擎及渲染主流程)
  - [2.1 渲染引擎（The rendering engine）介绍](#21-渲染引擎the-rendering-engine介绍)
  - [2.2 渲染主流程（The main flow）](#22-渲染主流程the-main-flow)

[3 文档解析（含DOM树构建）](#3-文档解析含dom树构建)
  - [3.1 解析（Parsing）- 综述](#31-解析parsing--综述)
    - [3.1.1 语法（Grammars）](#311-语法grammars)
    - [3.1.2 解释器（Parsers） -- 语法分析器（Parser）和词法分析器（Lexer）的组合](#312-解释器parsers----语法分析器parser和词法分析器lexer的合)
    - [3.1.3 转换（Translation）](#313-转换translation)
    - [3.1.4 解析示例](#314-解析示例)
    - [3.1.5 词汇（vocabulary）和语法（syntax）规则的正式定义](#315-词汇vocabulary和语法syntax规则的正式定义)
    - [3.1.6 解释器类型（Types of parsers）](#316-解释器类型types-of-parsers)
    - [3.1.7 自动生成解释器](#317-自动生成解释器)
  - [3.2 HTML 解释器（HTML Parser）](#32-html-解释器html-parser)
    - [3.2.1 非上下文无关文法](#321-非上下文无关文法)
    - [3.2.2 DOM](#322-dom)
    - [3.2.3 解析算法（The parsing algorithm）](#323-解析算法the-parsing-algorithm)
    - [3.2.4 词元识别算法（The tokenization algorithm）](#324-词元识别算法the-tokenization-algorithm)
    - [3.2.5 树构建算法（Tree construction algorithm）](#325-树构建算法tree-construction-algorithm)
    - [3.2.6 解析后续操作](#326-解析后续操作)
    - [3.2.7 浏览器的容错机制](#327-浏览器的容错机制)
  - [3.3 CSS 解析（CSS parsing）](#33-css-解析css-parsing)
    - [WebKit CSS 解释器](#webkit-css-解释器)
  - [3.4 JavaScript及CSS解释顺序](#34-javascript及css解释顺序)
    - [JavaScript](#javascript)
    - [预解释（speculative parsing）](#预解释speculative-parsing)
    - [CSS](#css)

[4 渲染树构建（Render tree construction）](#4-渲染树构建render-tree-construction)
  - [4.1 渲染树和 DOM 树的关系](#41-渲染树和-dom-树的关系)
  - [4.2 渲染树构建流程](#42-渲染树构建流程)
  - [4.3 样式计算（Style Computation）](#43-样式计算style-computation)
    - [4.3.1 WebKit - 共享样式数据（Sharing style data）](#431-webkit---共享样式数据sharing-style-data)
    - [4.3.2 Gecko - 规则树（ rule tree）](#432-gecko---规则树-rule-tree)
      - [结构划分（Division into structs）](#结构划分division-into-structs)
      - [通过规则树计算样式内容](#通过规则树计算样式内容)
    - [4.3.3 对规则进行处理以简化匹配](#433-对规则进行处理以简化匹配)
    - [4.3.4 根据优先级（正确的层叠顺序，correct  cascade order）应用样式规则](#434-根据优先级正确的层叠顺序correct--cascade-order应用样式则)
      - [样式表层叠顺序（样式表优先级）](#样式表层叠顺序样式表优先级)
      - [优先级权重（特异性）](#优先级权重特异性)
      - [样式规则排序](#样式规则排序)
    - [4.4 渐进式处理](#44-渐进式处理)

[5 布局（Layout）- 文档流](#5-布局layout--文档流)
  - [5.1 脏标记机制（Dirty bit system）](#51-脏标记机制dirty-bit-system)
  - [5.2 全局布局和增量布局（Global and incremental layout）](#52-全局布局和增量布局global-and-incremental-layout)
  - [5.3 异步布局和同步布局（Asynchronous and Synchronous layout）](#53-异步布局和同步布局asynchronous-and-synchronous-layout)
  - [5.4 布局优化（Optimizations）](#54-布局优化optimizations)
  - [5.5 布局过程（layout process）](#55-布局过程layout-process)
  - [5.6 宽度计算](#56-宽度计算)
  - [5.7 折行（Line Breaking）](#57-折行line-breaking)

[6 绘制（Painting）](#6-绘制painting)
  - [6.1 全局绘制和增量绘制](#61-全局绘制和增量绘制)
  - [6.2 绘制顺序（The painting order）](#62-绘制顺序the-painting-order)
  - [6.3 Gecko  显示列表（display list）](#63-gecko--显示列表display-list)
  - [6.4 WebKit 矩形缓存（rectangle storage）](#64-webkit-矩形缓存rectangle-storage)

[7 动态变化（Dynamic changes）](#7-动态变化dynamic-changes)  

[8 渲染引擎的线程](#8-渲染引擎的线程)  

[9 CSS2 视觉模型](#9-css2-视觉模型)
  - [9.1 画布](#91-画布)
  - [9.2 CSS 盒模型（CSS Box model）](#92-css-盒模型css-box-model)
  - [9.3 定位方案（Positioning scheme）](#93-定位方案positioning-scheme)
  - [9.4 三种基础盒子类型](#94-三种基础盒子类型)
  - [9.5 定位方案实现](#95-定位方案实现)
    - [相对定位（Relative）](#相对定位relative)
    - [浮动（Floats）](#浮动floats)
    - [绝对定位和固定定位（Absolute and fixed）](#绝对定位和固定定位absolute-and-fixed)
  - [9.6 层级绘制](#96-层级绘制)

[10 主要参考资料](#10-主要参考资料)

<!-- /TOC -->

## 0 序言

本文很全面地介绍了开两种源浏览器引擎（ WebKit 和 Gecko）内部运行原理，是塔利·加希尔（Israeli developer Tali Garsiel，一名以色列开发人员）花费了几年时间查阅并研读了所有公开发布的关于浏览器内部机制的数据（参见[主要参考资料](#res)）和网络浏览器的源代码后的成果。

塔利在她[主页上](http://taligarsiel.com/)写道：

> 在 IE 占据 90% 市场份额的年代，我们除了把浏览器当成一个“黑箱”，什么也做不了。但是现在，开放源代码的浏览器拥有了[过半的市场份额](http://techcrunch.com/2011/08/01/open-web-browsers/)，因此，是时候来揭开神秘的面纱，一探网络浏览器的内幕了。呃，里面是数以百万行计的 C++ 代码... 

保罗·爱丽诗（Paul Irish，Chrome 浏览器开发人员）也为本文推荐道：

> 如果你是一名Web开发人员，**学习浏览器的内部工作原理能帮助你作出更明智的决策，并理解那些我们作为经验之谈的最佳开发实践（development best practices）的原理**。尽管这是一篇相当长的文章，如果你愿意花些时间认真研读，我能保证你定然不会失望。

## 1 浏览器简介

现如今，浏览器是是人们使用最广泛、最普遍的软件。那么从在地址栏输入`baidu.com` 回车后直到浏览器屏幕上呈现百度首页的时间里发生了什么？这个过程中浏览器都做了什么工作呢？通过本文，我们将一步步了解到他们的内部工作原理。

### 1.1 本文会讨论到的浏览器

目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。本文主要参考开源放源代码浏览器，即 Firefox、Chrome 浏览器和 Safari（部分开源）。根据 [StatCounter 浏览器统计数据](http://gs.statcounter.com/)，目前（2018 年 6 月）Firefox、Safari 和 Chrome 占有的PC端市场占有率合计超过 77%。显而易见，开源浏览器在浏览器市场中占据了绝对优势。

### 1.2 浏览器的主要功能

浏览器的主要功能是渲染呈现指定网络资源（web resources），它会根据用户输入的 URI地址（统一资源定位符，Uniform Resource Identifier ）向服务器请求该资源，然后将其渲染后展示在浏览器窗口中。这里所说的资源是通常是一个 HTML 文档，有时则是一个 PDF、图片或其他文档类型。

浏览器根据 HTML 和 CSS 规范解析、呈现HTML文件。这些规范由网络标准化组织 W3C（万维网联盟，World Wide Web Consortium ）进行维护。 
曾经的一段时间内（主要指IE为主流浏览器的时期），各浏览器只部分遵循这些规范并倾向于开发自己独有的扩展程序，导致网络开发时有严重的兼容性问题。如今，浏览器大体上都遵从规范，兼容性问题也越来越少。

浏览器的用户界面有很多彼此相同的元素，其中包括：

- 地址栏（Address bar，用来输入 URI）
- 前进和后退按钮（Back and forward buttons）
- 书签相关选项（Bookmarking options）
- 刷新和停止按钮（Refresh and stop buttons，刷新用于刷新和停止加载当前文档）
- 主页按钮（Home button，用于返回主页）

浏览器的用户界面并没有任何正式的规范，这是多年来各浏览器厂商相互模仿改进而形成的最佳实践。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也有自己特有功能，比如 Firefox 有的下载管理功能。

### 1.3 浏览器的高层结构

浏览器的主要组件为 ([1.1](#res1))：

1. **用户界面**（**User interface** ） - 包括地址栏、前进/后退按钮、书签菜单等界面组件。除了浏览器主窗口（即展示你看到页面内容的窗口）的各个部分都属于用户界面。
2. **浏览器引擎**（**Browser engine** ） - 负责在用户界面和渲染引擎之间接收、组织并传送指令。
3. **呈现引擎**（**Rendering engine** ） - 负责渲染并呈现请求的网页内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 文件，并将解析后的内容渲染显示在屏幕上。
4. **网络**（**Networking** ） - 如 HTTP 请求。各平台基于统一的接口用各自的底层方法实现网络调用。
5. **用户界面后端**（**UI backend** ） - 负责绘制组合框、弹窗这样的基本组件，为上层提供通用样式接口（底层由浏览器基于各操作系统用户界面组件实现）。
6. **JavaScript 解释器**（**JavaScript interpreter** ）。负责解析和执行 JavaScript 代码。
7. **数据存储**（**Data storage** ）。这是持久层。浏览器需有时需要在硬盘上保存各种数据如 Cookie。HTML5规范还定义了其他的数据存储机，包括localStorage、 IndexedDB、WebSQL 和 FileSystem 。

![图1：浏览器的主要组件](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/layers.png)

图1：浏览器的主要组件

值得注意的是，浏览器如Chrome在渲染多个标签页时会分别为每个标签页分配独立的渲染引擎实例（instances of the rendering engine）。每个标签页都有一个独立的进程。

## 2 渲染引擎及渲染主流程

### 2.1 渲染引擎（The rendering engine）介绍

渲染引擎的作用...自然就是渲染，也就是在浏览器的屏幕上渲染呈现请求的内容。

默认情况下，渲染引擎可显示 HTML 、XML 和图片。通过插件（plug-ins）或浏览器扩展程序（extension ），还可以显示其他类型的内容；例如，借助 PDF 插件就能显示 PDF 文档。这里我们只聚焦渲染引擎的主要用途：渲染呈现由 CSS 格式化的 HTML 文档和图片。

本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的——Firefox 使用 **Gecko**（ Mozilla 公司自主研发的渲染引擎），而 Safari 浏览器使用 **WebKit**；另外，Chrome 和 Opera (从15版本开始) 使用 Blink , 一个基于WebKit的分支实现。

WebKit 是一款开源的渲染引擎，起初只支持 Linux 系统，后由 Apple 公司改进而支持Mac和 Windows系统。更多详情，请参阅 [webkit.org](http://webkit.org/)。

### 2.2 渲染主流程（The main flow）

渲染引擎首先会于网络层获取请求文档的内容，内容的大小通常不超过 8kB （注：塔利发布此文的时候是2009年11月,参见[其主页文章](http://taligarsiel.com/Projects/howbrowserswork1.htm)）。

然后进行如下所示的基本流程：

![图2：渲染引擎的基本流程](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/flow.png)

图2：渲染引擎的基本流程

1. **构建DOM节点树（DOM tree）** - 渲染引擎会解析 HTML 文档，并将各标记逐个转化成“内容树（content tree ）”上的 [DOM](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#DOM) 节点，构成DOM节点树（DOM tree，Document Object Model Tree，文档对象模型节点树）。

2. **构建[渲染树（Render Tree）](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Render_tree_construction)**- 渲染引擎解析外部 CSS 样式、内部样式，以及行内样式里的样式信息（styling information ）。这些样式信息加上HTML 中其他视觉相关指令一起构成了渲染树。

   渲染树由一个个带有颜色、尺寸等视觉属性的矩形渲染对象（Render Objects）构成，它们已按照将在屏幕上显示的顺序排列好。

3. **布局处理阶段（layout process）** - 在这个阶段，渲染引擎会为每个节点确定其呈现在屏幕上的确切坐标。

4. **[绘制阶段（painting process）](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Painting)** - 最后就是绘制阶段，渲染引擎会遍历渲染树，由UI后端层（UI backend layer ）将每个节点绘制出来。 

这里要提一点，整个过程不是一个过程完成后才进行另一个过程即顺序执行的，而是交叉并行的渐进过程。因为渲染引擎需要尽可能快递地将内容显示在屏幕上，以达到更好的用户体验。因此它并不会等到整个 HTML 文档解析完毕之后才开始构建呈现树和设置布局，事实上渲染引擎会优先解析显示网页的一部分内容，同时继续接收和处理来自网络传来的其余内容。

**主流程示例**

![图3：WebKit 主流程](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png)

图3：WebKit 主流程

![图4：Mozilla 的 Gecko 渲染引擎主流程 (3.6)](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image008.jpg)

图4：Mozilla 的 Gecko 渲染引擎主流程 ([3.6](#res3))

从图 3 和图 4 可以看出， WebKit 和 Gecko 整体流程是基本相同，只是使用的术语有些不同：

-  Gecko 的渲染流程中在解析HTML之后/形成 DOM 树之前比 WebKit 多了一个负责生成 DOM 元素的工厂层--**内容槽（Content Sink）**。
- Gecko 将视觉格式化元素组成的树称为**框架树（Frame tree ）**。每个元素都是一个框架。WebKit 使用的术语是**渲染树（Render Tree）**，它由渲染对象（Render Objects）组成。
- 对于元素的放置，WebKit 使用的术语是**布局（layout ）**，而 Gecko 称之为**回流（Reflow ）**。
- 对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是**添加（attachment）**，而 Gecko 称为**框架构造（Frame constructor）**。

接下来我们逐一论述流程中的每一个部分：

## 3 文档解析（含DOM树构建）

### 3.1 解析（Parsing）- 综述

 解析（Parsing）是渲染引擎中非常重要的一个环节，因此本文会讲解地更深入一些。

首先简要地介绍一下，解析文档是指将文档转化成为有意义的、代码能够理解和使用的结构。解析得到的结果通常是表现了文档结构的节点树，称作**解析树**（parse tree）或者**语法树**（syntax tree）。

举个例子，解析 `2 + 3 - 1 `这个表达式，会返回下面的树结构：

![图5：数学表达式树节点](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image009.png)

图5：数学表达式树节点

#### 3.1.1 语法（Grammars）

解析基于文档所遵循的语法规则（文档的编写语言或格式）。所有可以解析的文本格式都遵循着由词汇、语法规则构成的特定文法，这种特定文法称为[上下文无关文法（CFG, context free gramma）](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#context_free_grammar)。人类语言并不符合这种特性，因此无法为常规的解析技术进行解析。

#### 3.1.2 解释器（Parsers） -- 语法分析器（Parser）和词法分析器（Lexer）的组合

解析的过程可以分成两个子过程：词法分析和语法分析。

- **词法分析**（**lexical analysis**）是将输入内容分解为成**词法单元**（**tokens**）的过程。**词法单元**（**tokens**）是构成该语言的基本字符单元，可以理解为一门语言中的词汇表，相当于人类语言中语言字典中所有的单词集合。
- **语法分析**（**syntax analysis**）是对代码应用语言的语法规则组织词法单元构建表达式的过程，最终形成一颗抽象的层次化结构，即语法解析树。

相对应地，**解释器**（**Parsers**）通常将解析工作分给以下两个组件来处理：

- **词法分析器**（**Lexer 或者 tokenizer**）会剔除代码中无关的字符，如空格和换行符；将输入内容分解成有效的词法单元的集合。
- **语法分析器**（**Parser**）负责根据语言的语法规则分析文档的结构，构建语法解析树。

![图6：从源文档到解析树](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image011.png)

图6：从源文档到解析树

解析是一个迭代的过程。每当语法分析器向词法分析器获取一个新词法单元，会尝试将其与语法规则进行匹配。

- 如果有匹配规则，语法分析器会添加该词法单元的对应节点（node）到语法解析树中，然后向词法分析器请求下一个词法单元。
- 如果没有匹配规则，语法分析器就会将词法单元存储到内部，并重复取词-解析的过程，直至找到可与所有内部暂存的词法单元匹配的规则。
- 如果实在找不到任何匹配规则，语法分析器就会抛出一个异常。这意味着该文档无效或者包含语法错误。

#### 3.1.3 转换（Translation）

很多时候，语法解析树并不是最终结果。解析之后通常还要转换（Translation）	，将输入文档转换成另一种编排格式。

举个例子，编译（compilation）的最终结果就不是语法解析树，而是机器码（machine code，一种计算机能直接执行的代码）。编译器（compiler）首先将源代码（source code）解析成语法解析树，然后将解析树进一步转换（translate ）成机器码文档。

![图7：编译流程](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image013.png)

图7：编译流程

（注：编译器在此只是用于解说转化这一步骤的存在，HTML、CSS、JavaScript都是解释型语言而非编译语言，并不会像编译型语言如C、C++会直接把源代码编译成机器码；关于解释型语言可参考[百度百科](https://baike.baidu.com/item/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/8888952)）

#### 3.1.4 解析示例

现在，我们以图5为例来简单演示一下怎么把一个表达式解析为语法解析树。

首先我们要规定一个简单的数学语言，由前述课可知须包含其词汇和语法规则两部分。

词汇：该语言可包含不小于零的整数(即自然数)、加号和减号。

​        （注：因为例子输入为“2+3-1”，规定这几个就够用了）

语法规则：

1. 该语言的语法单位包括表达式（expression）、项（term）和操作符（operation）。
2. 该语言可包含任意多个表达式。
3. 一个表达式定义为：两个“项”通过一个“操作符”连接。
4. 操作符可以是加号或减号。
5. 项是一个整数或一个表达式。

现在让我们解析一下输入“ 2 + 3 - 1 ”：
匹配语法规则的第一个子串是 “ 2 ”，根据第 5 条语法规则，它是一个项。

匹配语法规则的第二个子串是 “ 2 + 3 ”，根据第 3 条规则（两个项由操作符连接），这是一个表达式。

下一个匹配项已经到了输入的结束“ 2 + 3 - 1 ”，这是一个表达式，因为根据第5条规则，“ 1 ”是一个项，表达式“ 2 + 3 ” 也是一个项，这样“ 2 + 3 - 1 ”就符合第3条规则。

如果输入是“ 2 + + ”，即一个项接两个操作符，可以看出不与上述我们规定的任何规则匹配，因此在我们这个例子中是无效的输入。

#### 3.1.5 词汇（vocabulary）和语法（syntax）规则的正式定义

词汇通常用[正则表达式](http://www.regular-expressions.info/)表示。

例如，我们在前面例子构建的数学语言的词汇可以用定义如下：

```C
INTEGER : 0|[1-9][0-9]* 
PLUS : +
MINUS: -
```

这上面的不小于0的整数（integer）就是用正则表达定义的，该正则表达式的作用是匹配0，或者以1-9开头的纯数字序列。

语法通常使用 [BNF](https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F)（Backus Normal Form，巴科斯范式） 来定义，这里引用基维百科原话介绍一下BNF：

> **BNF** 规定是[推导规则](https://zh.wikipedia.org/w/index.php?title=%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99&action=edit&redlink=1)(产生式)的集合，写为：
>
> <符号> := <使用符号的表达式>
>
> 这里的 <[符号](https://zh.wikipedia.org/wiki/%E7%AC%A6%E5%8F%B7)> 是[非终结符](https://zh.wikipedia.org/wiki/%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6)，而[表达式](https://zh.wikipedia.org/wiki/%E8%A1%A8%E8%BE%BE%E5%BC%8F)由一个符号序列，或用指示[选择](https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9)的[竖杠](https://zh.wikipedia.org/w/index.php?title=%E7%AB%96%E6%9D%A0&action=edit&redlink=1) '|' 分隔的多个符号序列构成。
>
> 每个符号序列整体都是左端的符号的一种可能的[替代](https://zh.wikipedia.org/w/index.php?title=%E6%9B%BF%E4%BB%A3&action=edit&redlink=1)。从未在左端出现的符号叫做[终结符](https://zh.wikipedia.org/wiki/%E7%BB%88%E7%BB%93%E7%AC%A6)。

我们在前面例子构建的数学语言的语法规则可以定义如下：

```C++
expression :=  term  operation  term
operation :=  PLUS | MINUS
term := INTEGER | expression
```

之前我们说过，如果语言符合上下文无关文法，就可以由常规解析器进行解析。而上下文无关文法的直观定义就是可以用 BNF 格式表达的语法。有关上下文无关文法的正式定义，请参阅[维基百科](https://zh.wikipedia.org/wiki/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95)。

#### 3.1.6 解释器类型（Types of parsers）

**常规解释器**有两种基本类型的解析器：**自上而下解释器**和**自下而上解释器**。

直观地来说，自上而下的解释器从语法高层结构出发，尝试寻找匹配的规则。而自下而上的解析器从输入出发，逐步将输入转化为语法规则，先匹配低层语法然后直到满足高层语法规则时匹配高层语法。

现在通过演示解析 “ 2 + 3 - 1” 来进一步了解一下这两种解析器：

- 自上而下解释器会从高层的规则开始：首先识别出表达式“ 2 + 3 ”；然后识别表达式 “ 2 + 3 - 1 ”（识别表达式的过程涉及匹配其他规则，但出发点是最高级别的规则）。

- 自下而上解释器将从头扫描输入内容，如果扫描的内容匹配某个规则，就将这部分输入替换成该规则。如此继续替换，直到输入内容的结尾。替换的规则保存在解释器的堆栈（stack）中：

  1. 输入为“ 2 + 3 - 1 ” ，自下而上解释器的指针初始指向输入头部，堆栈为空；
  2.  解释器扫描到输入“2”，符合语法规则中对项的定义，因此指针右移（等效于去除输入序列中的2）并在自己堆栈中插入一个项；
  3.  解释器扫描到输入“+”，符合语法规则中的操作符PLUS，于是指针右移并往堆栈中添加操作符；
  4. 解释器扫描到输入“3”，是一个项，右移并往堆栈中添加项，此时堆栈中内容为“项 操作符 项”，符合表达式的定义，因此将堆栈中内容替换为“表达式”；
  5. 解释器继续扫描输入“-”，符合语法规则中的操作符MINUS，于是指针右移并往堆栈中添加操作符；
  6. 解释器扫描到输入“1”，是一个项，右移并往堆栈中添加项，此时堆栈中内容为“项 操作符 项”，符合表达式的定义，因此将堆栈中内容替换为“表达式”；

  | 输入（Input） | 堆栈（Stack） |
  | ------------- | ------------- |
  | 2 + 3 - 1     |               |
  | + 3 - 1       | 项            |
  | 3 - 1         | 项 操作符     |
  | - 1           | 表达式        |
  | 1             | 表达式 操作符 |
  |               | 表达式        |

  这种自下而上解释器又称为移位解析器（shift-reduce parser），因为输入在不断向右移位而减短（设想有一个指针从输入开头向右移动直到到结尾），从而逐渐转换成语法规则。

#### 3.1.7 自动生成解释器

有一些工具可以自动生成解释器。你只要向其提供语言的语法（词汇和语法规则），它就会生成相应的解释器。鉴于开发解释器需要开发者对解析有深刻理解，同时人工开发一个最优的解释器并不容易，使用专业的解释器生成器（parser generator ）是非常不错的选择。

WebKit 使用了两种非常有名的解释器生成器： [Flex](http://en.wikipedia.org/wiki/Flex_lexical_analyser) （也称Lex，用于生成词法分析器）和 [Bison](http://www.gnu.org/software/bison/)（也称Yacc，用于生成语法分析器）。Flex 的输入是所有词法单元的正则表达式定义。Bison 的输入是所有语法规则的 BNF 格式。

### 3.2 HTML 解释器（HTML Parser）

我们知道，HTML全称超文本标记语言（Hypertext Markup Language），HTML 解释器的任务就是将 HTML 标记（HTML markup）解析成语法解析树。

#### 3.2.1 非上下文无关文法

HTML 的词汇和语法规则由 W3C 组织发布的[规范](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#w3c)定义。

正如我们前面了解到的，语法规则可以用 BNF 等格式进行正式定义。

遗憾的是，HTML 并不能用常规解释器所需的上下文无关文法来定义，因此**常规解释器都不适用于 HTML**（前面介绍的常规解释器对我们依然有意义，因为它们可以用于解析 CSS 和 JavaScript）。

DTD（Document Type Definition，文档类型定义） 给出了正规格式以定义HTML 文档，但它不是与上下文无关的语法。

我们知道，HTML 和 XML 非常相似，甚至 HTML 还有一个基于 XML 的版本XHTML。但不同于HTML，XML可以使用常规解释器进行解析。这初看起来很奇怪：它们之间的区别在哪呢？

区别就在于**HTML 的解析处理更为“宽容”**，它允许您省略某些标记（这些标记会在解释中被隐式添加），甚至还允许你漏写了双标签的起始标签（start tag）或者结束标签（end tag）等等。总的来说，HTML使用的是一种“弹性”、有容错空间的语法，而 XML 则使用非常严格，不容错的语法。

这一看似细微的差别导致了完全不同的结果。一方面，正是这个特点使 HTML 流行于全球：它能包容一定的错误，这使得网页开发工作变得更轻松简单。另一方面，这又使得它语法规则编写变得困难，无法很容易地通过常规解释器解析。

（注：在前文我们知道HTML是有一定容错的，而容错意味着在发现错误时就需要解释器尝试去纠正错误比如纠正缺失了结束标签的双标签，就需要根据上下文进行分析判断，因而HTML的语法是上下文有关的，不符合上下文无关文法，也就不能被只支持上下文无关文法的常规解释器解析。）

**HTML DTD**

HTML 的定义采用了 DTD 格式。此格式可用于定义基于 [SGML](http://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language) 的语言。HTML DTD定义了所有允许使用的元素及其属性和层次结构的定义，同时如前文所述，它不属于上下文无关文法。

HTML DTD 存在一些分支版本。其中严格模式（strict mode ）完全遵循 HTML 规范定义，其他模式则同时支持已过时的旧HTML标记以向下兼容一些早期版本的内容。

（注：HTML5 的文档类型声明使用<!DOCTYPE html>，不再需要对DTD进行引用--HTML 4.01 中的文档类型声明 需要对 DTD 进行引用是其基于 SGML；而 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但仍需要文档类型声明标明文档所使用的HTML 规范。）

#### 3.2.2 DOM

HTML解释器输出的语法解析树是一个DOM（Document Object Model，文档对象模型，由 DOM 元素和属性节点构成的树结构）。DOM是 HTML 文档的对象表示，是外部内容（例如 JavaScript）与 HTML 元素之间的接口。 
DOM的根节点是“[Document](http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document)”对象。

DOM 与HTML元素几乎是一一对应的关系。比如下面这段标记：

```html
<html>
  <body>
    <p>
      Hello World
    </p>
    <div> <img src="example.png"/></div>
  </body>
</html>
```

可解析成如下的 DOM 树：

![图8：示例标记的 DOM 树](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image015.png)

图8：示例标记的 DOM 树

和 HTML 一样，DOM 规范也是由 W3C 组织维护的，参见 [www.w3.org/DOM/DOMTR](http://www.w3.org/DOM/DOMTR)。它规定了通用的HTML文档操作，每一个HTML元素都有一个特定模块专门描述。HTML 元素( element )的定义可以在这里找到：[www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html](http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html)。

上面所述的DOM树包含了 DOM 节点，指的是DOM树是由一个个实现了 DOM 接口的元素构成的。在具体的实现中,各浏览器在规范基础之上往往还会拓展一些供内部使用的其他属性。

#### 3.2.3 解析算法（The parsing algorithm）

如前述，HTML 无法用常规的自上而下或自下而上的解释器进行解析。

原因在于：

1. HTML自身的容错语法。
2. 一直以来，浏览器对一些无效 HTML 用法有自己的容错机制。
3. html的解析过程是往复的。我们所知的大多数编程语言源码在解析过程中是不变的，但对于 HTML 中，一些动态代码（现多为JavaScript代码）往往会对HTML添加额外的标记。举个例子，假设HTML文档中中有`script` 元素且`script` 元素调用了 `document.write()`方法，则解析到`script` 元素时调用该方法实际上等效于就更改整个HTML输入，解释器需要重新构建DOM。

由于不能使用常规的解析技术，浏览器就开发了特定的解释器来解析 HTML。

[HTML5 规范](http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html)详细地描述HTML解析算法。此算法由两个阶段组成：**词元化**（tokenization）和**树构建**（tree construction），分别对应词法分析和语法分析。

词元化就是词法分析的过程，将输入内容解析成多个词法单元（tokens）。HTML 词法单元包含**起始标记（start tag）、结束标记（end tag）、属性名（attribute name）和属性值（attribute value）**。

词法分析器（tokenizer）识别各个词法单元，传递给树构造器（tree constructor），然后读取下一个字符（character）以识别下一个词法单元；如此反复直到处理完所有输入。

![图9：HTML 解析流程(摘自 HTML5 规范)](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image017.png)

图9：HTML 解析流程（摘自 HTML5 规范）

#### 3.2.4 词元识别算法（The tokenization algorithm）

W3C组织在html5语法规则中详细规定了[词元识别算法](https://www.w3.org/TR/html5/syntax.html#tokenization)，该算法主要通过**状态机制**（state machine）实现以将输入流转换为 HTML 词法单元。

词元识别算法定义了不同的**词元识别状态**（tokenization stage），各个状态词法分析器会根据当前词元识别状态读取来自输入流的一个或多个字符，并根据这些字符判断是否要更新词元识别状态以保证正确读取下一个字符。词元识别状态的变更受当前词元识别状态以及**树构建状态**（tree construction state）共同影响。这意味着，即使读取的字符相同，也可能因不同的当前状态，在是否更新词元识别状态上衍生不同的判断结果。

该算法相当复杂不好详述，这里用一个简单的例子来解释这个原理。

简单示例 - 将下面的 HTML 代码词元化：

```html
<html>
  <body>
    Hello world
  </body>
</html>
```

词法分析器的初始词元识别状态是“**数据状态**（Data state）”。当读取（consume）到字符 `<` 时，词元识别状态变为“**标记打开状态**（Tag open state）”。接下来词法分析器读取到字符`h`，属于英文字符，就会标记现在正在识别一个**起始标签的词法单元**（start tag token），同时词法分析状态变为“**标签名称状态**（Tag name state）”。

标签名称状态下词元分析器读取的每个英文字符(在这里是`t` `m` `l` )都添加到刚创建的词法单元末端作为该单元的一部分。这个状态会一直保持到读取到 `>`字符，解释器知道此时标签名称已录入完毕，就这样词元分析器识别得到了 `html` 词法单元（html token），如前所述它已被标记为一个起始标签，词元分析器会将该词法单元发送（emit）给语法分析器以进行树构建（节点树的构建过程在下文讲解），同时自身词元识别状态由“标签名称状态”改回“数据状态。

词法分析器对接下来读取到的`<body>` 处理相同，识别得到 `body` 词法单元发送给语法分析器，并将自身改回回到“数据状态”。

接下来词法分析器读取到`H` 字符，`H` 字符不属于会`<`这种在HTML中有特定含义的字符，就会识别该字符为普通的字符词法单元（character token ）如`H`，发送给语法分析器，自身保持数据状态；词法分析器会为 `Hello world` 的每个字符创建并发送独立的字符词元。

当词法分析器读取到`</body>`的字符 `<` 时，词元识别状态变为“**标记打开状态**”。注意接下来词法分析器读取到字符 `/` ，它会标记现在正在识别一个**结束标签的词法单元**（end tag token），词元识别状态变为“标记名称状态”。接下来的处理我们都熟悉了，词法分析器识别 `body` 词法单元，不同的是这回它已已被标记为结束标签，词元分析器将词法单元发送给语法分析器并将自身词元分析器状态变回“数据状态”。接下来读取的`</html>` 处理过程基本一致，就不在此赘述。

![图10：对示例输入进行标记化](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image019.png)

图10：对示例输入进行标记化

（注：这里示例使用的是一个非常简单的HTML，涵盖的词元识别状态只是最常用的一小部分，如果你想了解完整详细的词元识别状态，可以参考[这里](https://www.w3.org/TR/html5/syntax.html#tokenization)）

#### 3.2.5 树构建算法（Tree construction algorithm）

（注：前文已述，HTML语法分析输出的语法解析树是一个DOM，并且它是一个树结构，有时为了形象会使用树之类的说法，表达其实是相同的含义；因此DOM、DOM树、节点树、DOM节点树指的都是DOM，树构建、节点树构建都表示DOM构建，以此类推。）

HTML的语法分析过程就是DOM树构建过程，为方便这里我们将HTML语法分析器称为树构建器（tree constructor ），HTML的语法分析算法称为树构建算法。

W3C组织在html5语法规则中亦详细规定了[树构建算法](https://www.w3.org/TR/html5/syntax.html#tree-construction)，该算法也借助**状态机制**（state machine）将词法分析器传入的词法单元按语法规则操作以构建DOM节点树。

（注：类似于词元识别算法，树构建算法定义了不同的状态，在前文我们为区别于词法分析器的状态机制时将它们称为树构建状态（tokenization stage），实际上html规范在具体到树构建算法时使用术语为**插入模式**（insertion mode），每一个插入模式对应一种状态，html规范里详细规定了每一个插入模式下对不同词法单元的处理，从而能够通过插入模式控制树构建的各种操作细节。）

树构建器在初始化节点树构建阶段（ tree construction stage ）的时候就创建了 Document 对象作为DOM的根节点。在整个节点树构建阶段，树构建器会不断修改DOM或者对其添加各种元素节点。

树构建器会立即对词法分析器发送过来的每个词法单元进行处理，对于标记为起始标签的词法单元，它会根据标签名创一个在html规范中对应的 DOM 元素，将DOM元素添加到 DOM 树上，同时会该DOM元素添加到**开放元素堆栈**（stack of open elements）底部。此堆栈主要用于指定插入节点的父元素还有纠正嵌套错误和处理未关闭的标签。

简单示例 - 分析下面HTML代码的树构建过程：

```html
<html>
  <body>
    Hello world
  </body>
</html>
```

树构建器的输入是词法分析器传入的词法单元序列。当树构建器初始化创建DOM树的根节点 Document 对象，初始化完毕后就设置插入模式为“**初始模式**”（initial）。树构建器接收了词法分析器传入的` html`开始标签后，根据规范定义得["initial mode"](https://www.w3.org/TR/html5/syntax.html#the-initial-insertion-mode)操作细则，将插入模式转为“**before html**”模式，然后在“before html”模式下重新处理` html`开始标签。

根据[“before html”](https://www.w3.org/TR/html5/syntax.html#the-before-html-insertion-mode)操作细则对` html`开始标签规定的处理，树构建器创建一个 HTMLHtmlElement 即HTML元素，并将添加到DOM树上作为 Document 根对象的子节点，同时将HTML元素添加到开放元素堆栈中，然后树构建器将插入模式变为“**before head**”。

接下来树构建器接收到` body`开始标签，根据[“before head”](https://www.w3.org/TR/html5/syntax.html#the-before-head-insertion-mode)操作细则，树构建器创建一个 HTMLHeadElement 即head元素（即使我们的示例中没有` head`开始标签），并将其添加到DOM树上成为html元素的子节点，同时将head元素添加到开放元素堆栈中，将插入模式改变为“**in head**”模式，在“in head”模式下重处理` head`开始标签。

（注：可能看到这里你会有点迷糊，因而Ciya在这里插入一段为大家再讲解一下插入模式。

如果你有点击上面的链接查看规范里对各个插入模式下的操作细则就会发现 -- 这些处理可以归分为三类：

1. 该模式下期望接收的词法单元及对应的操作 
2. 该模式下不应接收到的词法单元及对应的错误处理操作
3. 不属于这个模式下应处理的其他词法单元（Anything else ），则在处理完必要操作后切换为下一个插入模式，将词法单元按下一个插入模式的操作细则再处理一次。

以“in head”插入模式为例，其操作细则点[这里](https://www.w3.org/TR/html5/syntax.html#the-before-head-insertion-mode)可以查看：

- 细则规定了一些错误处理：比如接收到` DOCTYPE`声明、` html`开始标签会认为是语法错误，因为` DOCTYPE`声明应在HTML文件开头，在“initial mode”就处理过了；而` html`属于HTML文档中有且仅有一个的元素类别，当前模式下DOM树已经创建html元素。
- 细则规定了一些许可操作，即head元素的相关操作：接收到注释符号则创建一条注释，接收到"title" 起始标签、"meta" 起始标签等则创建相应的子节点等。
- 对于不属于以上两类的其他词法单元（Anything else ）：将开放元素堆栈里的head元素弹出，把插入模式变为“after head”，将该词法单元在“after head”模式下重处理一次。

我们都知道即使是空html文档浏览器也会渲染出html、head和body这三有且仅有一个的元素，就是依赖插入模式控制实现的，无论HTML文档中是否有html、head和body标签，树构建器最开始几个插入模式一定会有也一定按照这个顺序：“initial” - “before html” - “before head” - “in head” - “after head” - “in body”，在这些模式切换控制过程中构建DOM树的html、head以及body元素节点。

回归上面的示例HTML文档，显然` body`开始标签是”after head“模式下的期望操作，不属于“before head”和“in head”两个插入模式下应处理的词法单元，因而在“before head”模式下按其他词法单元处理--树构建器进行必须的构建head元素并将其添加到DOM和开放元素堆栈，切换为下一个插入模式”in head“重处理` body`开始标签；在”in head“模式下也按其他词法单元处理--树构建器会认为没有更多对head元素的相关操作了，因此将开放元素堆栈里的head元素弹出，把插入模式变为“after head”重处理` body`开始标签，此时开放元素堆栈中只有html一个元素，因而总指向堆栈最低元素的指针current node指向了html元素 。）

树构建器将插入模式由”in head“变为[**“after head”**](https://www.w3.org/TR/html5/syntax.html#the-after-head-insertion-mode)模式，对 body 标记进行重新处理，创建HTMLBodyElement即body元素，添加到DOM树上成为current node所指向的html元素的子节点，同时将body元素添加到开放元素堆栈底部，指针current node就自动指向了body元素，然后将插入模式转变为[**“in body”**](https://www.w3.org/TR/html5/syntax.html#the-in-body-insertion-mode)。

现在，树构建器会接收到词法分析器生成的对应源码“Hello world”字符串生成的一串字符词元序列。（注：对于字符词法单元规范给出了独立的操作细节，点[这里](https://www.w3.org/TR/html5/syntax.html#insert-a-character)可以查看具体流程。）

当树构建器接收到字符词元`H` 时，它会查看开放元素堆栈的另一个指针adjusted current node，看到当前可插入**文本节点**（Text node）的元素是body元素（DOM规范规定了Document对象不允许添加文本节点）且字符词元`H` 并不跟在其他字符字符词元之后（字符词元`H` 是序列的第一个），就创建一个包含该字符的文本节点添加到DOM树成为body的子节点。

（注：指针adjusted current node指向开放元素堆栈中可以插入内容节点的最底元素。通常情况下如果current node指向的元素可以添加文本节点，则指针adjusted current node和current node指向同一个元素，否则adjusted current node根据语法规则指向current node所指元素可添加文本节点的最近祖先元素。）

接下来接收到后续字符词元，由于紧跟在字符词元`H`，树构建器就不会构建新的文本节点，而是将字符词元添加在已创建好的文本节点的内容末端成为其内容的一部分。

处理完“Hello world”的字符词元序列，树构建器仍处于“in body”模式，接下来树构建器接收到了` body`结束标签，根据模式下操作细则，树构建器查看开放元素堆栈中是否存在一些该闭合还没闭合的元素，如存在则判断为有一个语法错误（需要暂停处理这个错误，下文讲解），如果没有则切换插入模式为[**“after body”**](https://www.w3.org/TR/html5/syntax.html#after-body)。

（注：这里并没弹出开放元素堆栈中的body元素，这是为了在“after body”模式处理到非文档收尾标签比如div的时候还能直接切回“in body”模式重新处理）

接下来树构建器接收到了` html`结束标签，按规则树构建器切换插入模式为[**“after after body”**](https://www.w3.org/TR/html5/syntax.html#after-after-body)。在"after after body"模式下树构建器接收到词法分析器传入文件结束标记EOF(end-of-file token )，表明到文档末端没有更多输入了，树构建器才认为解析过程结束了，才会开放元素堆栈。

![图11：示例 HTML 的树构建](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image022.gif)

图11：示例 HTML 的树构建

#### 3.2.6 解析后续操作

HTML解析结束后，浏览器会将文档状态标记为可交互状态，并开始解析HTML文件里外链的延时（在HTML解析完成后才执行的）的脚本如JavaScript文件。完成后，HTML解释器将文档状态将设置为“完成（complete)”，同时触发“加载（load）”事件。

#### 3.2.7 浏览器的容错机制

我们在浏览 HTML 网页时从来不会在浏览器窗口中看到“语法无效(Invalid Syntax)”的错误提示。这是因为浏览器会纠正任何无效内容，使之呈现为一个能够正常运作的网页。

以下面的 HTML 代码为例：

```html
<html>
  <mytag>
  </mytag>
  <div>
  <p>
  </div>
    Really lousy HTML
  </p>
</html>
```

上面代码已经违反了很多语法规则（“mytag”不是合法的标签，“p”和“div”元素有嵌套错误等等），但是浏览器仍然毫无怨言地纠正并正确地显示这些内容，这是因为它在解析过程中每判断有一个网页作者写下的语法错误时就进行了纠正。

各大浏览器的容错机制（Error handling）一致得令人称奇，因为HTML规范中并没有相应的规定，这和书签管理以及前进/后退按钮一样，是浏览器长期发展相互模仿进步的产物。很多网站都普遍存在着一些已知的无效 HTML 结构，各浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。

HTML5 规范定义了一部分错误处理操作。WebKit 将之概括并以注释的方式写在语法解析器代码的开头处：

> 语法解析器对传入的词法单元进行解析以构建文档树。如果文档书写规范，解析过程是非常流畅的。
>
> 遗憾的是，我们不得不处理书写不够规范的 HTML 文档，所以语法解释器必须具备一定的容错性。
>
> 我们至少要能够处理以下错误情况：
>
> 1. 要添加的元素在规范中明确禁止成为当前元素子元素的情况。此时应从开放元素堆栈最底元素开始逐级向上有这些禁止的元素，直到current node指向可添加该元素的节点，再加入该元素。
> 2. 依赖于上级不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。
> 3. 向 inline 元素内添加 block 元素。则关闭所有 inline 元素，直到出现下一个较高级的 block 元素。
> 4. 如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者选择忽略该标记。

现在看一些 WebKit 容错代码里的示例：

**例1：使用了` </br>` 而不是` <br>`**

有些网站使用了` </br>` 而不是` <br>`。为了与 IE 和 Firefox 一致，WebKit 将其与 `<br>` 做同样的处理。 
代码如下：

```C++
if (t->isCloseTag(brTag) && m_document->inCompatMode()) {
     reportError(MalformedBRError);
     t->beginTag = true;
}
```

请注意，错误处理是在内部进行的，用户并不会看到这个过程。

**例2：偏离的表格**

这是指一个表格是嵌套在另一个表格之内，但又不在被嵌套表格的单元格内。 
比如：

```html
<table>
    <table>
        <tr><td>inner table</td></tr>
    </table>
    <tr><td>outer table</td></tr>
</table>
```

WebKit 会将其层次结构纠正为两个同级表格：

```html
<table>
    <tr><td>outer table</td></tr>
</table>
<table>
    <tr><td>inner table</td></tr>
</table>
```

处理关键代码如下：

```C++
if (m_inStrayTableContent && localName == tableTag)
        popBlock(tableTag);
```

WebKit 使用一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格使两个表格成为兄弟关系。

**例3：嵌套的表单元素**

如果用户在一个表单元素中又放入了另一个表单，那么第二个表单将被忽略。 
代码如下：

```C++
if (!m_currentFormElement) {
        m_currentFormElement = new HTMLFormElement(formTag,    m_document);
}
```

**例4：过于复杂的标记层次结构**

这里有一段清晰的代码的注释:：

>  www.liceo.edu.mx 嵌套了约 1500 个标记，全都从` <b> `开始嵌套。我们只允许最多 20 层同类型标记的嵌套，如果再嵌套更多，就会全部忽略。

```C++
bool HTMLParser::allowNestedRedundantTag(const AtomicString& tagName)
{
unsigned i = 0;
for (HTMLStackElem* curr = m_blockStack;
         i < cMaxRedundantTagDepth && curr && curr->tagName == tagName;
     curr = curr->next, i++) { }
return i != cMaxRedundantTagDepth;
}
```

**例5：放错位置的 html 或者 body 结束标签**

同样，代码的注释已经说得很清楚了：

> 支持格式非常糟糕的 HTML 代码。我们从不闭合 body 标记，因为一些愚蠢的网页会在实际文档结束之前就关闭（给出html或body结束标签之后又插入其他内容标签）。我们通过调用 end() 来执行关闭操作。

```C++
if (t->tagName == htmlTag || t->tagName == bodyTag )
        return;
```

所以Web开发者们要注意了，除非你想作为反面教材出现在 WebKit 容错代码段的示例之中，请编写尽量规范的 HTML 代码。

### 3.3 CSS 解析（CSS parsing）

还记得解析综述中的内容吗？属于上下文无关文法的 CSS 可以使用综述中描述的常规解释器进行解析。点此查看[CSS 规范定义的 CSS 的词法和语法](http://www.w3.org/TR/CSS2/grammar.html)。

其词法规则（词汇）是正则表达式定义的，部分定义如下：

```
comment   \/\*[^*]*\*+([^/*][^*]*\*+)*\/
num   [0-9]+|[0-9]*"."[0-9]+
nonascii  [\200-\377]
nmstart   [_a-z]|{nonascii}|{escape}
nmchar    [_a-z0-9-]|{nonascii}|{escape}
name    {nmchar}+
ident   {nmstart}{nmchar}*
```

这里“ident”是标识符(identifier) 的缩写。“name”是元素的 ID（通过“#”来引用）。

语法规则采用 BNF 格式描述，部分定义如下：

```
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
selector
  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?
  ;
simple_selector
  : element_name [ HASH | class | attrib | pseudo ]*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : '.' IDENT
  ;
element_name
  : IDENT | '*'
  ;
attrib
  : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
    [ IDENT | STRING ] S* ] ']'
  ;
pseudo
  : ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ]
  ;
```

用个示例解释一下规则集（ruleset）的结构：

```
div.error , a.error {
  color:red;
  font-weight:bold;
}
```

div.error 和 a.error 是选择器（selector）。大括号内的部分包含了此规则集中的规则。这个示例规则集就是按下面这个BNF定义书写的：

```
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
```

BNF定义了，一个规则集是由 以一个或者由逗号和空格（S 表示空格）分隔的多个选择器开头、花括号包围的一条或多条由分号分隔的声明 构成的。

#### WebKit CSS 解释器

WebKit 使用 [Flex 和 Bison](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#parser_generators) 解释器生成器根据 CSS 语法文件自动生成的**自下而上解释器**。Gecko 使用的是自己开发的**自上而下解释器**。这两种解析器都会将每个CSS文件解析成一个包含 CSS 规则对象（CSSRule）的 样式表对象（CSSStyleSheet）。每个CSS 规则对象包含选择器文本（selectorText）和样式声明对象（ CSSStyleDeclaration ）。（注：由于本文作者创作此文于2008年，而W3C发布CSSOM规范时间为2016年12月，作者在文中部分用词已不太合适，Ciya查看规范后将本段进行了些许修改，如果你想了解更多可点此查看[CSSOM规范](https://www.w3.org/TR/cssom-1/#biblio-css3syn)）

![图12：解析 CSS](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image023.png)

图12：解析 CSS</center>

### 3.4 JavaScript及CSS解释顺序

本文不展开JavaScript解析这部分内容，仅说一下涉及JavaScript解析顺序的内容。

#### JavaScript

Web运作模型是同步/串行的。每当解释器在读到HTML文档的 `<script>` 标签时，HTML解释器就会暂停自身HTML解析工作，转而立即解释执行脚本代码直到脚本执行完毕。如果是外部脚本，解析过程也依然是同步、串行的，解释器会暂停所有解析工作等待从网络加载完脚本文件在继续。要避免这种状况，开发者可以为 `<script>` 标签添加`defer`属性，这样解释器就会在整个HTML文档解析完毕后再解析执行该脚本。HTML5规范中还增加了一种值得推荐的新选择，通过为 `<script>` 标签添加`async `属性（asynchronous 的缩写，异步/并行），则浏览器会新建一个线程异步解析执行该脚本。

#### 预解释（speculative parsing）

WebKit 和 Gecko 都做了这种优化：在执行脚本的同时，会有其他线程解析查找HTML文档剩余部分以提前加载其他需要通过网络加载的资源。通过这种方式，能够并行加载进而提高了网页呈现总体速度。需要注意的是，预解释器不修改 DOM ，这是主解释器的工作；预解释器只会在发现对外部资源（例如外链JavaScript、外链CSS和图片）的引用对资源进行加载。

#### CSS

CSS（样式表）的解析则遵从另一种模式。一方面，因为样式的应用是不会影响到 DOM 的结构，因而HTML解释器一旦读取到`style`标签和外链CSS，会在不停止自身HTML文档的继续解析的同时，交由CSS解释器立即开始进行CSS解释。

不过这里还有一种听起来像边界情况但实际却经常遇到的特殊情况需要解决：CSS还未解析完的时候就有脚本尝试去回去某些元素样式信息，此时如果那些元素样式信息还未解析完毕，脚本获取到的样式信息自然是错误的，进而产生很多问题。对此 Gecko 和 Webkit 采取不同的处理方式：Gecko 选择挂起所有脚本直到所有CSS加载解析完毕才执行。WebKit只在脚本尝试获取的样式属性可能受尚未加载解析的样式表影响使才会挂起该脚本。

## 4 渲染树构建（Render tree construction）

在 DOM 树构建的同时，浏览器还会构建另一个树结构：渲染树。渲染树由可见元素其显示顺序排列而成，是文档的可视化表示。渲染树的作用是让浏览器能够按照正确的顺序绘制文档内容。

Gecko 将渲染树中的元素称**框架（frame）**，WebKit 则称它们**渲染对象（render object / renderer ）**。 
渲染对象知道如何布局并将自身及其子元素绘制出来。 
WebKit 定义了类 RenderObject 为渲染对象基类：

```c++
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  //the DOM node 指向对应DOM节点
  RenderStyle* style;  // the computed style 指向计算后的样式信息
  RenderLayer* containgLayer; //the containing z-index layer 指向z-index
}
```

每个渲染对象用仪器和该节点CSS盒模型相对应的矩形区域表示。它包含了宽度、高度和位置等几何信息。 
CSS盒子的类型受该节点相关的“display”样式属性影响（请参阅本文[样式计算]()章节4.3）。下面这段 WebKit 代码描述了不同 display 属性对应创建的渲染对象盒子类型：

```c++
RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node->document();
    RenderArena* arena = doc->renderArena();
    ...
    RenderObject* o = 0;
    switch (style->display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }
    return o;
}
```

这里只列了其中一部分，具体实现中还有其他考虑因素比如元素类型中表单控件和表格等也具有特殊的盒子框架。 

 对于 WebKit ，如果一个元素需要创建特殊的渲染对象，就会重载 `createRenderer()`方法，使渲染对象指向一个不包含宽高位置等几何信息的样式对象。

### 4.1 渲染树和 DOM 树的关系

渲染对象是和 DOM 元素相对应的，但并非一一对应的。不可见的 DOM 元素不会插入到渲染树上，例如`head`元素。如果元素的 `display`属性值为 `none` 也不会被添加到呈现树中（但 `visibility` 属性值为`hidden`的元素会）。

有一些 DOM 元素对应多个可见对象，一般是具有复杂结构无法用单一矩形来描述的元素。例如，`select`元素有 3 个渲染对象分别渲染：显示区域，下拉列表框，按钮。还有，当文本由于当前宽度不够换行时，新添加的行会对应新的渲染对象。 
还有DOM元素与渲染对象一对多的例子多见于不够规范的 HTML。根据 CSS 规范，内联元素**只能包含块级元素（block element）或内联元素（inline element）中的一种**。如果内联元素同时包含了块级元素和内联元素，那么会创建匿名的块级渲染对象来包裹里面的内联元素。

有一些渲染对象在渲染树中所在的位置与 其对应的DOM节点在DOM树上的位置 并不相同。浮动定位和绝对定位的元素会脱离文档流，则渲染树上对应DOM节点的位置只是一个占位盒子，真正的渲染对象放在树的其他位置。

![图13：渲染树及其对应的 DOM 树 (3.1)](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image025.png)

图13：渲染树及其对应的 DOM 树 ([3.1](#res3))

### 4.2 渲染树构建流程

 Gecko 实现了一个监听DOM更新的监听器（listener），并将框架（前文已述，对应于Webkit中的渲染对象）创建工作委托给**框架构造器（FrameConstructor）**，由该构造器决定最终样式并生成框架。

 WebKit 将计算最终样式并生成渲染对象的过程称为**附接（attachment）**。每个 DOM 节点都有一个添加（attach）方法。通过调用一个节点的“attach”方法将该节点插入 DOM 树，这个过程是同步/串行的。

解析` html `和` body `标签时就会创建渲染树根节点。这个根渲染对象对应于 CSS 规范中的包含块（the containing block），一个在渲染树最顶层包含了其他所有块的块级元素。它的尺寸就是视口对象（viewport），即浏览器窗口显示区域的尺寸。视口对象在Gecko的实现为**ViewPortFrame对象**，在 WebKit的实现为**RenderView对象**。还有一点需要提一下，DOM树的根节点document对象指向的渲染对象就是视口对象。渲染树树的其余部分构建方法和DOM节点构建方式相同。

更多信息参阅[ CSS2 规范相关部分](http://www.w3.org/TR/CSS21/intro.html#processing-model)。

### 4.3 样式计算（Style Computation）

构建渲染树时需要计算每一个渲染对象的视觉相关属性，这通过计算每个元素的样式属性来完成。 

样式含各种来源的外链CSS文件、HTML文档内嵌的style元素、HTML 中的视觉相关属性（含style属性以及如bgcolor等属性，一般在解析中会被转换为相应的CSS 样式属性）。 

样式表的来源包括浏览器的默认样式表、开发者提供的样式表，及由浏览器用户提供的用户样式表（浏览器允许用户定义自己喜欢的样式，例如Firefox用户可以将自己喜欢的样式表放在“Firefox Profile”文件夹下）。 

样式计算存在以下难点： 

1. 样式数据总量非常大，在内存中存储这么大量的样式属性可能造成内存问题。

2. 需要优化为元素查找匹配样式规则的算法以避免渲染效率太低。因为遍历整个规则列表来为元素寻找匹配规则的方式会导致巨大的工作量。同时选择器结构很复杂的情况下，很容易导致渲染引擎沿一条看似正确的路径匹配到最后却发现不合适，然后重新尝试其他匹配路径。 

   如下面这个组合选择器：

   ```
   div div div div{
   
     ...
   
   }
   ```

   这个选择器要求渲染引擎匹配到嵌套了三层` div` 父级的 `div`元素。假设你要判断这个选择器是否匹配某个` div` 元素，就需要从这个` <div>`元素节点沿着DOM树向上检查。然后结果是你向上搜寻到根节点却发现这个` div` 元素嵌套了两层` div` ，选择器并不匹配该` div` 。然后，你必须换一个` div` 元素沿另一条路径向上检索。 

3. 样式表是级联，有着复杂的级联规则（继承、覆盖等等）。

让我们来看看浏览器是如何处理这些问题的： 

#### 4.3.1 WebKit - 共享样式数据（Sharing style data）

WebKit下，渲染树节点通过引用样式对象 (RenderStyle)关联样式。这些样式对象在某些情况下可以为多个树节点共享。这要求节点是同级关系，并且： 

1. 这些元素必须处于相同的鼠标状态（例如，不能一个含“:hover”伪类，而另一个不含）

2. 不能有元素有 ID
3. 标签名必须匹配
4. 类属性应匹配
5. 对应属性必须是完全相同
6. 链接状态必须匹配
7. 焦点状态必须匹配
8. 选择器内容不能包含属性选择器
9. 元素中不能有任何 style属性
10. 选择器内容不能包含任何同级选择器。渲染引擎在遇到任何同级选择器都会触发一个全局切换，停用整个文档的样式共享（如果存在）。这里说的同级选择器包括 `+ `选择器以及` :first-child ` 等选择器。

#### 4.3.2 Gecko - 规则树（ rule tree）

为了简化样式计算，Gecko 额外实现了两种树结构：规则树（rule tree）和样式内容树（style context tree）。WebKit 也有样式对象，但它们不是保存在类似样式内容树这样的树结构中，只是单纯在DOM 节点添加一个指针指向相关样式。

![图14：Gecko 样式内容树 (2.2)](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image035.png)

图14：Gecko 样式内容树 ([2.2](#res2))

样式内容（style context）为最终值（注：元素的最终应用样式）。计算最终值需要先按照正确顺序应用所有的匹配的样式规则，再将规则中的逻辑值换算为具体值，比如要将屏幕的百分比换算成绝对单位。使用规则树巧妙地使节点直接共享最终值从而避免了重复计算，同时也节省了存储空间。

所有匹配的样式规则都存储在规则树中。规则树种每条路径越底层的节点优先级越高。规则树包含了所有已知样式规则的匹配路径。规则存储是“懒操作”的，即规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加算得的路径。

因此我们可以把规则树路径类比为词典中的单词。如果我们已经计算出如下的规则树：

![图15：规则树](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/tree.png)

图15：规则树

假设我们需要为内容树中的另一个元素匹配规则，并且找到匹配路径（按正确顺序）是 B - E - I。由于我们在树中已经计算出了路径 A - B - E - I - L，从而减少了工作量。

接下来详细讲述一下规则树是怎么起到减低工作量作用的。

##### 结构划分（Division into structs）

样式内容会被划分为多个结构体。这些结构体包含了特定类别（如 border 或 color）的样式信息。结构中的属性可能是继承也可能是非继承的。

- **继承属性**是指元素自身未定义则会继承自其父代值的属性。
- **非继承属性**（也称为“重置”属性）是指如果元素自身未定义则使用默认值的属性。

规则树会缓存了完整的结构体（包含计算最终值），这样如果底层节点没有提供某个样式的定义，则课向上层节点的缓存结构中搜寻。

##### 通过规则树计算样式内容

要计算某个元素的样式内容，首先需要计算规则树中的对应路径，或者使用已有路径。然后我们沿此路径将样式规则填充到新的样式内容中。我们从路径中拥有最高优先级的最底层节点（通常对应路径上特异性即优先级权重最高的选择器，关于特异性权重会在本文后面介绍）向上遍历规则树，直到样式结构填满。如果当前规则树节点没有定义所需的规则，则向上寻找直到找到定了以改规则的节点然后将指针指向该节点即可。这是最好的优化方法，因为整个结构都是共享的，同时做到了减少最终值计算量和节约内存。 

如果在路径上完全找不到该样式的定义，对于继承属性，直接样式内容树的样式内容节点的这一样式属性指向父级样式内容，通过这种方式共享结构。如果是非继承属性，则会采用默认值。

如果底层节点添加了相对值，则需要进行额外的计算将其转化为实际值，并将结果缓存在树节点中以供子节点参考。

如果某个元素与其同级元素都指向同一个树节点，那么它们就可以共享**整个样式内容**。

来看一个例子，假设HTML代码如下 ：

```html
<html>
  <body>
    <div class="err" id="div1">
      <p>
        this is a <span class="big"> big error </span>
        this is also a
        <span class="big"> very  big  error</span> error
      </p>
    </div>
    <div class="err" id="div2">another error</div>
  </body>
</html>
```

以及如下样式规则：

```css
/*1.*/  div {margin:5px;color:black}
/*2.*/  .err {color:red}
/*3.*/  .big {margin-top:3px}
/*4.*/  div span {margin-bottom:4px}
/*5.*/  #div1 {color:blue}
/*6.*/  #div2 {color:green}
```

这里简化一下，假设只需要填充两个样式（结构）：color 和 margin。color 结构只包含一个成员（即“color”），而 margin 结构包含四条边。 
最终会生成如下规则树（节点的标记方式为“ 节点名 : 指向的规则序号 ”）：

![图16：示例代码的规则树](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image027.png)

图16：示例代码的规则树

 

生成样式内容树如下（节点名 : 指向的规则节点）：

![图17：示例代码的样式内容树](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image029.png)

图17：示例代码的样式内容树

当解析到HTML文档的第二个` div `元素时，我们需要为此节点创建样式内容对象，并填充其样式结构。 
经过规则匹配，我们发现该 `div` 的匹配样式规则有 1、2 和 6 （注：因为HTML第一个 `div` 匹配规则1、2、5，因此规则1、2在HTML解析到第一个 `div` 的时候就经换算然后添加到规则树上）。我们发现规则树中已有路径1、2，因此只需要换算规则6并将其添加到规则树上（规则树中的 F 节点）。 
然后创建一个样式内容节点插入到样式内容树中，令其将指向规则树中的 F 节点（注：因为规则6的选择器匹配范围包含该元素且范围最小即最具有特异性）。

接下来我们需要为样式内容对象填充样式。先是 margin，由于规则节点 (F) 并margin相关样式定义，则需要继续沿路径（F-C-B）上溯规则树节点是否有margin样式定义。最终在路径最顶节点即B节点找到margin样式定义并采用该样式。

对于 color ，因为F节点有color样式声明，就不需要再上溯规则树寻找color；将F节点color声明的属性值换算为RGB后将最终值存储在该节点。

再说说解析到第二个 `span` 元素的处理过程，这个过程其实更简单些。首先确定匹配样式规则，然后我们会发现发现它和前一个的 span 匹配规则一致，因而一样指向规则 G。既然和同级为指向同一个节点，就直接共享同个样式内容对象了，只需令DOM中的 `span` 元素指向解析前一个 `span` 元素时创建的样式内容对象即可。

还有一点需要注意：继承属性是存储在样式内容树中的（例子中用的margin是非继承属性，因而存储在规则树中；当然按CSS规范定义 color 应该是继承属性，但 Firefox 将其实现为重置属性，因此也是存储到规则树上）。 
举个继承属性的例子，比如为`div`元素添加 font 样式规则：

```css
div {font-family:Verdana;font size:10px;font-weight:bold}
```

那么，样式内容树的`p`元素对应样式内容对象（图17中的Paragraph节点），就会共享父节点Div存储的 font 样式（提一下前提，该HTML中的`p`元素自身没有 font 声明）。

WebKit 不使用规则树，它通过四次遍历元素的匹配规则以实现样式计算：第一次遍历计算未声明`!important`高优先级的属性（display之类其他属性计算时需要参考到的属性），第二次遍历计算高优先级且声明`!important`的样式规则，然后是普通优先级未声明`!important`的规则，最后计算普通优先级声明`!important`的规则。Webkit 通过这种方式使多次声明的样式能够按照正确的层叠顺序进行解析，最后解析的样式声明覆盖了前面相同属性的样式声明，即为最终生效的样式。 

总结地说，通过共享样式对象可以解决样式计算的难点1、3。Gecko 实现了规则树以优化样式计算。

#### 4.3.3 对规则进行处理以简化匹配

样式规则来源于：

- 外链样式（外链CSS文件）、内嵌样式（HTML文件里`style`标签）：

  ```css
  p {color:blue}
  ```

- 行内样式（标签的style属性）：

  ```html
  <p style="color:blue" />
  ```

- HTML 视觉相关属性（会被解析映射为对应的样式规则）:

  ```html
  <p bgcolor="blue" />
  ```

（注：这里的规则匹配指的是为DOM元素填充样式时进行的操作：查找匹配该元素的样式规则。）

其中行内样式和HTML属性匹配DOM元素很容易，因为他们直接关联了DOM元素：行内样式直接成为DOM元素的属性，HTML视觉相关属性在映射CSS规则的时候也会以DOM元素为键（key）。

但外链样式和内嵌样式的匹配（涉及选择器）则如前述难点2那样比较棘手。针对这一难题，可以先对样式规则进行一些处理以便于访问。

样式表解析完毕后，系统会根据样式规则集的选择器将样式声明添加到[哈希表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)（hash map）中。这些哈希表以不同类别的选择器为Key保存样式声明，有id映射、类名（class name）映射、标签名（tag name）映射等，还有一种通用哈希表，负责映射不包含在上述类别的选择器。如果id选择器，则将规则集里的样式声明添加到id映射表中；如果类选择器，则将样式声明添加到类映射表中，以此类推。 
这种处理可以大大简化规则匹配工作。我们无需查看每一条样式规则集，只要从这些哈希表中提取出DOM元素相关的规则即可。这种优化方法为规则匹配过程排除掉 95% 以上的样式规则，大大减轻了规则匹配的负担 ([4.1](#res4))。

以如下的样式规则为例：

```css
/*1.*/  p.error {color: red}
/*2.*/  #messageDiv {height: 50px}
/*3.*/  div {margin: 5px}
```

规则1会被添加到类映射表，规则2会被添加到id映射表，规则3会被添加到标签映射表。 
对于下面的 HTML 代码段：

```html
<p class="error">an error occurred </p>
<div id="messageDiv">this is a message</div>
```

先为` p `元素进行规则匹配，然后在类映射表找到值为“error”的key，继而在error下的规则列表中找到选择器文本为“p.error”的规则。为`div `元素进行规则匹配时则会找到两个哈希表中找到相关的样式规则：标签映射表和id映射表，剩下的工作就是判断提取到的样式规则是否真的适用于该DOM元素了。 
举个例子来解释一下这种情况，假设还有一条样式规则如下：

```css
/*4.*/  table div {margin:5px}
```

- （注：这里需要提一点，如上合并了多个单一选择器的选择器文本，其最右的单一选择器才是**关键选择器**（匹配最终要应用的元素，前面的选择器可以认为只是为这最后选择器增加了限定条件；因而判断一个样式规则集应该插入到哪个映射表通常只依据其选择器文本中关键选择器。规则4的选择器文本为“table div”，关键选择器为div，因而规则4会以“div”为key插入到标签映射表中。

  现在我们重新为`div `元素进行规则匹配，会在id映射表中提取到规则2，在标签映射表key为“div”处提取到规则3和规则4。）

没错，为`div `元素进行规则匹配时会从标记表中提取出来规则4，因为它的key也是“div”，但这条规则并不匹配示例HTML代码段中的 `div `元素，因为它并不存在满足“ table”的祖先元素。
WebKit 和 Gecko 都进行了这一处理。

#### 4.3.4 根据优先级（正确的层叠顺序，correct  cascade order）应用样式规则

样式对象包含了对应每一个视觉相关属性的CSS属性。样式对象中没有被样式规则定义的属性，就会根据其是否继承属性而继承父元素样式对象的属性值或者采用默认值。

当一个属性在多个样式规则中有定义时，就需要通过层叠顺序来解决采用哪一个值。

##### 样式表层叠顺序（样式表优先级）

一个样式属性可能在多个样式表中有声明，也可能在同一个样式表中声明多次。因此应用这些规则的顺序极为重要，称为层叠顺序。根据 CSS2 规范，层叠顺序为（优先级从低到高）：

1. 浏览器声明
2. 用户普通声明
3. 开发者普通声明
4. 开发者重要声明
5. 用户重要声明

浏览器声明是优先级最低，用户声明则只有在用户将该声明标记为重要（`!important`）才会替换开发者声明。层叠顺序相同的声明会根据**特异性（优先级权重）**进行排序。HTML视觉相关属性则会转换成对应的 CSS 声明，层叠顺序等同为开发者普通声明。

##### 优先级权重（特异性）

选择器的优先级权重定义如下（[CSS2.2 规范](https://www.w3.org/TR/2016/WD-CSS22-20160412/cascade.html#specificity)）：

- 记录**是否为行内样式**即写在DOM元素的style属性内的样式声明，是记为 1，否则记为 0 (= a)
- 记录选择器文本中**id选择器**的个数 (= b)
- 记录选择器文本**属性选择器**和**伪类**的个数 (= c)
- 记录选择器中**元素选择器**（对应标签名）和**伪元素**的个数 (= d)

然后将四个数字按 a-b-c-d 这样连接起来成为一个数（数的进制即基数取决于abcd中的最大值），构成特异性（优先级权重）。

例如，如果abcd中的最大值为d=14，则使用十六进制。如果d=17，就需要使用十七进制；当然不太可能出现这种情况，除非是选择器文本如：“html body div div p ...”（包含17个标签选择器，这种可能性极低）。

一些优先级权重示例（注：计算后的优先级权重会存为specificity属性）：

```css
 *             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */
 li            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */
 li:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */
 h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */
 ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */
 li.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */
 #x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */
 style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */
```

##### 样式规则排序

回归正题，为DOM元素匹配规则之后（注：提取的样式规则会放入一个列表中），就会根据优先级权重将其排序。如果列表较小，WebKit 会使用[冒泡排序](https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)，如果列表较大则使用[归并排序](https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)。

WebKit 重载了“>”操作符来实现排序：

```c++
static bool operator >(CSSRuleData& r1, CSSRuleData& r2)
{
    int spec1 = r1.selector()->specificity();
    int spec2 = r2.selector()->specificity();
    return (spec1 == spec2) : r1.position() > r2.position() : spec1 > spec2;
}
```

### 4.4 渐进式处理

WebKit 使用一个标识符来标记是否所有CSS文件（含 `@imports`导入的）都已加载。

如果在添加时（计算最终样式并生成渲染对象的过程，具体回见本章节顶部）样式尚未完全加载，则放置一个占位符，并在文档中进行标记，等样式表加载完毕后再重新计算。

## 5 布局（Layout）- 文档流

渲染对象创建并添加到渲染树时还不没有定位（position）和尺寸（size）信息。计算这些值的过程称为**布局（layout）**或**回流（reflow）**。（注：WebKit中称布局， Gecko 中称回流，参见前面章节 - 主流程示例）

HTML 采用基于流的布局模型，这样通常只要一次遍历就能计算完几何信息。因为**处于文档流中**靠后位置元素通常不会影响到靠前位置元素的几何特征，因此布局**自左向右、自上而下**处理文档。但其中有些特殊情况，比如 HTML 对表格元素（table）的布局计算过程需要不止一次的遍历 (3.5)。

文档流的定位坐标系以根渲染对象（viewport）为参考的自左向右（x轴）、自上而下（y轴）的坐标系。

布局过程是一个递归的。它从跟渲染对象（对应于DOM的`html`元素）开始，然后按**层级**递归地遍历渲染对象，为每一个有需求的渲染对象计算几何信息。

跟渲染对象的定位为（ 0,0），其尺寸等于视口（浏览器窗口大小）。
每个渲染对象都有layout方法（或reflow方法），由父渲染对象调用需要布局的子渲染对象的 layout 方法（或reflow方法）。

### 5.1 脏标记机制（Dirty bit system）

为避免每次有细小变动就对整个文档流重布局一次，浏览器采用了一种**“脏机制”**：如果某个渲染对象有变动，就会将自身及所有子代渲染对象打上脏标记（“dirty”位 置1），表示这些对象需要进行布局。

有两种位标记：**“dirty”**和**“children are dirty”**。“children are dirty”置1 表示尽管渲染对象自身没有变动，但它至少有一个子代元素有变动需要布局。

### 5.2 全局布局和增量布局（Global and incremental layout）

全局布局是指，对整个渲染树进行布局，触发原因包括：

- 影响所有渲染对象的全局样式更改，例如根对象字体大小更改。
- 窗口大小重置（会触发resize事件）。

增量布局是指，只对“dirty”位标识置1的渲染对象进行布局（但需要进行额外布局的情况下可能会出现问题）。 
当渲染对象标识为脏时，就会触发（异步/并行）增量布局。例如，从网络中接收到新的内容解析后有新元素添加到 DOM 树，新的渲染对象也会添加到渲染树中并置脏位以触发增量布局。

![图18：增量布局(3.6)](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/reflow.png)

图18：增量布局([3.6](#res3))

### 5.3 异步布局和同步布局（Asynchronous and Synchronous layout）

增量布局是异步执行的。Gecko 设置了一个队列来放置增量布局的回流命令，由调度器（batch ）触发这些命令的批量执行。WebKit 利用间隔一定时间触发计时器执行增量布局：遍历渲染树查找并布局那些标记为脏的渲染对象。 还有一点需要提一下，当脚本及JavaScript代码执行过程中请求如“offsetHeight”等样式信息触发的增量布局是同步的（注：JavaScript会挂起等待 增量布局计算出该样式信息后 才继续执行，因而是同步的）。 

全局布局往往是同步执行的。

有时布局是通过回调函数触发的， 
当初始全局布局完成之后，会为一些属性添加回调函数以执行相关布局，比如为`body`元素的滚动条添加回调函数，当触发滚动事件（onscroll）时就会执行回调函数，触发增量布局更改被滚动元素的scrollHeight属性。

### 5.4 布局优化（Optimizations）

- 如果布局是由“resize”事件或渲染对象定位改变（尺寸不变）而触发的，则可以延用渲染对象的尺寸信息，无需重新计算。 
- 如果只是渲染树的一个分支需要重新布局，则不需要从根节点开始布局；即当元素自身有变更但不影响周围元素的情况，例如`textarea`元素的文本发生变化时，就从其渲染对象开始布局即可（否则的话，每次键盘输入都将触发从根节点开始的布局）。

### 5.5 布局过程（layout process）

布局一般按此模式进行：

1. 父渲染对象确定自己的宽度。
2. 父渲染对象依次处理子渲染对象：
   1. 定位子渲染对象（设置其x和y坐标）
   2. 必要时调用子呈现器的布局方法以计算子渲染对象的高度（当全局布局或者子渲染对象标脏位为1时，也可能有其他原因）。
3. 父渲染对象综合其子渲染对象累加的高度和自身margin、padding等相关值计算出自己的高度（以供父渲染对象自身及其父级使用）
4. 父渲染对象将自身脏标识位（dirty bit）置0，表示当前已布局完毕不再需要布局。

Gecko 在每次布局会传入一个参数 nsHTMLReflowState对象，该对象包含了当前渲染对象的父渲染对象宽度。 
Gecko 布局会输出一个nsHTMLReflowMetrics对象，该对象包含了计算得出的当前渲染对象高度。

### 5.6 宽度计算

（注：如我们所熟知的盒模型，宽度指的是元素width属性生效的宽度即元素内容区“content-box”的宽度）

渲染对象宽度计算涉及其包含块（[containing block](https://www.w3.org/TR/CSS22/visudet.html#containing-block-details) ）的宽度、自身宽度样式（width属性）以及内外边距、边框等相关属性。 
以该 div 为例计算其宽度（假设整个HTML只有这一行代码）：

```html
<div style="width:30%"/>
```

 WebKit 会按以下流程计算`div`元素的渲染对象宽度（调用BenderBox 类的calcWidth 方法）：

1. 计算包含块宽度：取其可用宽度（availableWidth）和 0 中的较大值（即确保可用宽度不小于0）。本例中包含块可用宽度就是包含块内容区宽度（contentWidth），按以下公式计算：

   ```c++
   clientWidth() - paddingLeft() - paddingRight()
   ```

   clientWidth 和 clientHeight 代表一个渲染对象减去边框和滚动条后剩余区域的宽度和高度。

2. 计算元素宽度：百分比值（30%）乘以包含块宽度算得绝对值（注：使用px之类绝对单位的值）。

3. 计算并调整元素内外边距、边框宽度，使满足块元素盒模型宽度公式：

   > 左外边距 + 左边框 + 左内边距 + 元素宽度 + 右内边距 + 右边框 + 右外边距  = 包含块宽度 

   （注：如果公式里的属性均有声明且计算值不满足该公式，就会调整一些属性以满足公式并将调整后的值存于渲染对象里（这种情况下就布局使用值就和样式表应用值有偏差了，表现为审查网页元素时会发现某一条样式应用了但实际布局与应用样式值不一致，比如当等式左边大于右边即包含块宽度时，调整方式通常为忽视右外边距计算值，我们审查网页元素就会发现margin-right规则显示应用状态，实际布局却不符合该样式规则）

在本例中`div`元素的渲染对象宽度就计算出来等于元素宽度了。不过更多的情境下还有一步：此时计算出来这个宽度称为“推荐宽度”（preferred width），还需要计算元素最大宽度和最小宽度（如果存在“max-width”样式声明和“min-width”样式声明），根据这三个值确定最终使用的宽度：如果推荐宽度大于最大宽度，则使用最大宽度。如果推荐宽度小于最小宽度，则使用最小宽度。
宽度最终值会缓存起来以备增量布局时的调用之需。

（注：鉴于浏览本文基本都是网页开发者，对定位计算和尺寸计算规则是很熟悉的，因而作者在此没有展开详细说明，只举了个简单块元素宽度计算的例子，实际计算规则还有很多其他情况[点此可以查看CSS2.1规范](https://www.w3.org/TR/CSS22/visudet.html#Computing_widths_and_margins)）

### 5.7 折行（Line Breaking）

如果渲染对象（如含长文本的`span`元素对应渲染对象）在布局过程中需要折行，会立即停止自身布局过程并告知其父渲染对象需要拆分内容以折行。父渲染对象就会创建额外的渲染对象（对应匿名行框元素，具体会在后文绘制章节中介绍）并调用其布局方法。

## 6 绘制（Painting）

在绘制阶段，渲染引擎会遍历渲染树，并调用渲染对象的绘制方法（`paint()`）将其内容显示在屏幕上。绘制过程是基于用户界面基础组件（见前文浏览器的高层结构章节）完成的。

### 6.1 全局绘制和增量绘制

和布局一样，绘制也分为全局和增量两种方式。就增量绘制来说，一些渲染对象发生了只影响渲染树一部分的更改，这些渲染对象就将其在屏幕上显示的对应矩形区域设为无效，这系统将认为这是一块脏（dirty）区域，系统会很巧妙地将多个脏区域合并视为一个区域，继而触发一个绘制事件（paint event）。

因为 Chrome 浏览器的渲染对象存储于其他进程而非主进程中，无法借助系统的事件机制所以绘制事件触发会复杂一点。Chrome 浏览器模仿系统对绘制等相关事件进行监听，并派发消息给渲染树根渲染对象。然后通过遍历渲染树直到找齐有变动的渲染对象，令其调用方法重新绘制自己（通常也包括其子代）。

### 6.2 绘制顺序（The painting order）

[CSS2 规范定义](https://www.w3.org/TR/CSS21/zindex.html)了绘制流程的顺序。绘制的顺序其实就是元素被压入样式堆栈的顺序（后面层级一章会讲解）。绘制过程会根据堆栈顺序自屏幕靠后一层层往屏幕靠前绘制；块元素渲染对象的样式堆栈顺序如下（从低至高）：背景颜色 -> 背景图片 -> 边框 -> 子代 -> 轮廓（outline）

### 6.3 Gecko  显示列表（display list）

Gecko 遍历渲染树为要绘制的矩形区域建立一个显示列表。列表存放了与绘制区域相关的渲染对象并按照正确的绘制顺序排列好了（含所有相关渲染对象的背景样式边框样式等等）。这样需要重绘时，只需遍历一次渲染树就渲染完全部内容，而不用多次遍历（首遍历绘制所有背景，重遍历以绘制所有图片，再遍历以绘制所有边框等等）。

Gecko 还对该过程做了一点优化，显示列表中不添加看不到的元素，例如被高层级不透明元素完全遮挡住的元素。

### 6.4 WebKit 矩形缓存（rectangle storage）

在重新绘制之前，WebKit 会将原来的矩形区域保存为位图（bitmap），然后比对位图只绘制新旧矩形区域之间的差异部分。  

## 7 动态变化（Dynamic changes）

浏览器面对每个变更时都总是尽可能将布局和重绘操作减到最少。因此，改变一个元素的边框颜色，则浏览器只会对该元素进行布局重绘。如果改变一个元素的位置，则浏览器会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加一个 DOM 节点，浏览器会对该节点（及受影响节点）进行布局和重绘。

而如增大“html”元素的字体这样的重大变化好、就会导致整个渲染树的缓存失效，从而触发全局布局和全局重绘。

## 8 渲染引擎的线程

渲染引擎是单线程的。除了网络加载操作几乎所有操作都是在同一线程中进行的。在 Firefox 和 Safari 中，该线程就是浏览器的主线程。而在 Chrome 浏览器中，该线程是网页的主线程（注：一个浏览器能同时打开多个网页，Chrome会为每个网页分配一个渲染引擎实例和进程）。  

网络加载操作由多个并行线程负责进行。并行连接数是有限的（通常为 2 至 6 个）。

**事件循环（Event loop）**

浏览器的主线程本质为一个事件循环。它是一个无限循环，永远处于接受处理状态，等待事件（如布局和绘制事件）发生，并进行处理。这是 Firefox 中关于事件循环的代码：

```c++
while (!mExiting)
    NS_ProcessNextEvent(thread);
```

## 9 CSS2 视觉模型

### 9.1 画布

 [CSS2 规范](http://www.w3.org/TR/CSS21/intro.html#processing-model) 使用“画布”作为术语来描述渲染对象所占空间，也就是需要浏览器绘制内容的区域。理论上，画布在每个空间维度方向都可以无限延伸，因此浏览器会根据视口（viewport）的尺寸为画布设置初始宽度。

 [CSS2规范](http://www.w3.org/TR/CSS2/zindex.html) 规定了，如果一个画布包含在其他画布内，就设置为是透明色；否则由浏览器指定一种颜色（即背景色默认值）。

### 9.2 CSS 盒模型（CSS Box model）

每个DOM元素会根据[CSS 盒模型](http://www.w3.org/TR/CSS2/box.html)生成一些矩形区域这些矩形根据盒模型计算尺寸和布局。 
每个盒子（DOM元素）必有一个矩形 -- 内容区域（content area，包含文本、图片等），可能有也可能没有的矩形包括 -- 内边距（padding）、边框（border）和外边距（margin）区域。

![图19：CSS2 盒模型](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image046.jpg)

图19：CSS2 盒模型

每一个DOM节点都会生成 0到n 个这样的盒子。 

所有元素都有一个“display”属性，决定了自身生成为什么类型的盒子。例如：“display”属性值为“block”则生成块级盒子（block box），值为“inline”则生成一个或者多个（有折行的情况）内联盒子。“display”属性值为“none”则不生成任何盒子。

浏览器底层实现中所有元素生成时“display”属性默认值是 inline，通过应用浏览器样式表更改为W3C规范给出的默认值。例如，浏览器样式表中设置`div`元素的 display 属性为block，从而改写了`div`元素的display属性默认值。  

[点此查看W3C规范给出的默认样式表示例](www.w3.org/TR/CSS2/sample.html)

### 9.3 定位方案（Positioning scheme）

有三种定位方案：

1. 普通流定位：对象根据自身在文档中的位置进行定位（对象在渲染树中的位置和它在 DOM 树中的位置一致），并根据其盒子类型和尺寸信息进行布局。
2. 浮动定位：对象先按照普通流进行布局，然后尽可能地向左或向右移动。
3. 绝对定位：对象在渲染树中的位置和它在 DOM 树中的位置不同（元素脱离文档流）。

定位方案是由“position”属性和“float”属性决定的。

- 如果“position”值是 static 或 relative，采用普通流定位
- 如果“position”值是 absolute 或 fixed，则采用绝对定位
- 如果“float”值是left 或 right，则采用浮动定位 

每个元素的“position”值默认为 static，保持文档流的定位即可，因而不需任何定位计算等操作。对于其他情况（除浮动），就需要Web开发员指定必要的位置属性值：top、bottom、left、right。

一个盒子的布局由这些因素共同决定：盒子类型、盒子尺寸、定位方案，以及如图片大小和屏幕大小等影响布局的额外信息。

### 9.4 三种基础盒子类型

（注：[CSS盒模型](https://www.w3.org/TR/css3-box/#introduction)定义了三种盒子类型：块级盒子、内联盒子和行级盒子。

块级盒子（block-level box，block box）特性和我们所知`div`元素特性一致：独占一行，不设宽度时其宽度自动填充父级内容区宽度；设置宽高属性生效；上下内外边距会影响布局等。

内联盒子（inline-level box，block box）特性和我们所知`span`元素特性一致：内联元素可存在于同一行，行间挤不下则自动折行；宽度由内容撑开，高度由行高属性决定；设置其宽高属性不生效；设置上下内外边距不影响布局等。

行级盒子（line box）：用于包含内联元素的匿名盒子，所谓匿名盒子是指那些在网页渲染过程中产生了，但不会添加到DOM的盒子（因而对开发者来说是透明的，不可获取也不可设置样式的盒子）。行级盒子用于包含内联盒子，宽度占满一行，它负责布局这一行的内联盒子的布局：比如让这一行的内联盒子的基线对齐在同一条线上（各基线y坐标值相同），行级盒子高度取这一行内连盒子最大高度值结合基线确定等。

知道这三中盒子类型我们不难推测出规范本意：块级盒子就像专门装盒子的容器--负责垂直布局不管水平方向；内联盒子就负责放具体内容，根据内容撑起水平宽度，不需要管垂直布局，其垂直布局交由行级盒子实现；行级盒子就是那个直接包含一整行内联盒子的盒子，它负责根据规则控制一整行内联盒子排布，并撑起整一行的高度从而和块级盒子一起构成网页的垂直布局。

现在我们可以理解为何CSS规范有如下规定了：块级盒子可以直接包含块级盒子或者行级盒子的一种，但不能同时包含块级盒子和行级盒子，因为两者的布局规则并不一致。如出现混合存在的情况，则生成匿名块级盒子包裹行盒子使转变为只包含块级盒子的情况，实现时尽量用最少的匿名块级盒子。）

块级盒子：生成一个块级特性区域。

![图20：块级盒子示意图](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image057.png)

图20：块级盒子示意图

内联盒子：但是位于容器块级盒子内，没有自己的块级特性区域。

![图21：内联盒子示意图](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image059.png)

图21：内联盒子示意图

由下图可以看出两者排布特性：块级盒子按垂直方向延伸，内联盒子按水平方向延伸排列。

![图22：块级盒子和内联盒子排布特性](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image061.png)

图22：块级盒子和内联盒子排布特性

行级盒子：行级盒子和其内最高的内联盒子一样高，或者更高（比如基线对齐的一行中，最高的内联元素为一个图片，则行级盒子高度为图片高度加上行基线距离行底部的高度）。如果行级盒子的宽度不够放下所有内联元素，就会拆分剩余内联元素放置到新的行级盒子中。

![图23：行级盒子](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image063.png)

图23：行级盒子

（注：在介绍盒模型的时候我们提到了元素根据其“display”属性值决定生成什么类型的盒子，而display值只“inline”和“block”，因而读者可能会疑惑为什么基础盒子类型只有块级盒子和内联盒子以及没有对应display属性值的行级盒子。其实“inline-block”、“list-item”等值对应的盒子类型是基于块级盒子和内联盒子可能还结合些许样式实现的。

比如“inline-block”对应的内联块盒子在实现时通过在内联盒子包含一个块级盒子构成，它实际有两个盒子，但开发者在操作其DOM元素时不需要特别指定作用于外层的内联盒子还是内层的块级盒子上，就如同只有一个盒子。

[点此可以查看CSS规范中提到的dispaly值对应盒子类型实现方式](https://www.w3.org/TR/css3-box/#types)  ）

### 9.5 定位方案实现

#### 相对定位（Relative）

先按照普通稳定流方式定位，然后根据所需偏移量进行移动。

![图24：相对定位](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image065.png)

图24：相对定位

#### 浮动（Floats）

浮动盒子会移动到行的左边或右边，其他盒子会自动围绕在它的周围。下面这段 HTML 代码：

```
<p>
  <img style="float:right" src="images/image.gif" width="100" height="100">
  Lorem ipsum dolor sit amet, consectetuer...
</p>
```

显示效果如下：

![图25：浮动](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image067.png)

图25：浮动

#### 绝对定位和固定定位（Absolute and fixed）

这种情况下的布局时不考虑普通文档流，元素完全脱离普通文档流。此时元素的尺寸是相对于其包含块计算的。对于固定定位，包含块就是视口（viewport）。

![图26：固定定位](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image069.png)

图26：固定定位

 

需要注意的一点，相对视口定位意味着，文档滚动时，固定定位元素保持其位置不变，不会跟随文档流移动。

### 9.6 层级绘制

（注：Ciya修订了原文整个小节的表达以更准确地阐述本节内容。）  

[CSS2.1](https://www.w3.org/TR/CSS2/visuren.html#layers)中写道，每个盒子都有三个维度的定位：水平坐标、垂直坐标、z轴。z轴的方向为由后向前，即z轴垂直于显示屏自屏幕靠后向屏幕往前z坐标值递增，这个z坐标我们称之为层级。层级低的盒子先绘制，层级高的盒子后绘制。当盒子之间发生重叠时，层级高的盒子会遮挡在层级低的盒子。

一个盒子的层级由浏览器计算得出，开发者只有特定情况下才能通过“z-index”属性设置盒子的层级。我们都知道，普通盒子（“position”属性为 static 的盒子）的定位信息不受“top”，“bottom” ，“left”，“right”四个CSS属性影响的，就算开发者设定了这四个值也只会被浏览器忽略掉。盒子的层级也一样，只有对定位盒子（“position”属性值为 relative 或 absolute 或者 fixed ）设定“z-index”属性才会生效，其余情况都可以视为“z-index”固定为auto，由浏览器按规则计算得出。

所有盒子都会被分配到某个堆叠栈中（CSS规范中称这类栈为stacking content）。根渲染对象会生成一个根堆叠栈，之后只有解析到定位盒子时才会创建新的堆叠栈。

每个盒子都按照[CSS规范规定的顺序](https://www.w3.org/TR/CSS2/visuren.html#layers)放置于当前堆叠栈中：

> Within each stacking context, the following layers are painted in back-to-front order:
>
> 1. the background and borders of the element forming the stacking context.
> 2. the child stacking contexts with negative stack levels (most negative first).
> 3. the in-flow, non-inline-level, non-positioned descendants.
> 4. the non-positioned floats.
> 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.
> 6. the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.
> 7. the child stacking contexts with positive stack levels (least positive first).

其中，每当解析到一个定位盒子时根据其“z-index”设定值（如果没设定则为0）调整它在当前堆叠栈中的位置，同时为该定位元素创建一个新堆叠栈（可以看做当前堆叠栈的子堆叠栈），定位盒子里的 子盒子及后代盒子 就放置于这个新生成的子堆叠栈中，而不会放置在定位盒子所处的堆叠栈。

堆叠栈之间层级相互独立，即盒子的层级只影响其在所处堆叠栈中的绘制顺序。

示例：

```html
<style type="text/css">
      div {
        position: absolute;
        left: 2in;
        top: 2in;
      }
</style>

<p>
    <div
         style="z-index: 3;background-color:red; width: 1in; height: 1in; ">
    </div>
    <div
         style="z-index: 1;background-color:green;width: 2in; height: 2in;">
    </div>
 </p>
```

绘制结果如下：

![图27：示例绘制结果图](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image071.png)

图27：示例绘制结果图

如果示例中两个`div`元素没有设置定位属性，按普通文档流自左向右、自上而下的绘制顺序，红色块应该被绿色块遮盖；如示例代码对两者设定绝对定位且设置层级后，红色块层级为3，比绿色块（层级为2）层级更高，因此绿色块先绘制，后绘制的红色块遮挡绿色块产生如图所示的绘制结果。

<a id="res"></a>
## 10 主要参考资料

1. 浏览器架构<a id="res1"></a>
	- 1.1  Grosskurth, [Alan. A Reference Architecture for Web Browsers (pdf)](https://grosskurth.ca/papers/browser-refarch.pdf)
	- 1.2  Gupta, Vineet. [How Browsers Work - Part 1 - Architecture](http://www.vineetgupta.com/2010/11/how-browsers-work-part-1-architecture/)

2. 解析<a id="res2"></a>
	- 2.1  Aho, Sethi, Ullman, Compilers: Principles, Techniques, and Tools（即“Dragon book”）, Addison-Wesley, 1986
	- 2.2  Rick Jelliffe. [The Bold and the Beautiful: two new drafts for HTML 5](http://broadcast.oreilly.com/2009/05/the-bold-and-the-beautiful-two.html ).

3. Firefox<a id="res3"></a>
	- 3.1  L. David Baron, [Faster HTML and CSS: Layout Engine Internals for Web Developers](http://dbaron.org/talks/2008-11-12-faster-html-and-css/slide-6.xhtml )
	- 3.2  L. David Baron, [Faster HTML and CSS: Layout Engine Internals for Web Developers（Google 技术访谈视频）](https://www.youtube.com/watch?v=a2_6bGNZ7bA)
	- 3.3  L. David Baron, [Mozilla's Layout Engine](http://www.mozilla.org/newlayout/doc/layout-2006-07-12/slide-6.xhtml)
	- 3.4  L. David Baron, [Mozilla Style System Documentation](http://www.mozilla.org/newlayout/doc/style-system.html)
	- 3.5  Chris Waterson, [Notes on HTML Reflow](http://www.mozilla.org/newlayout/doc/reflow.html)
	- 3.6  Chris Waterson, [Gecko Overview](http://www.mozilla.org/newlayout/doc/gecko-overview.htm)
	- 3.7  Alexander Larsson, [The life of an HTML HTTP request](https://developer.mozilla.org/en/The_life_of_an_HTML_HTTP_request)

4. WebKit<a id="res4"></a>
	- 4.1  David Hyatt, [Implementing CSS（第一部分）](http://weblogs.mozillazine.org/hyatt/archives/cat_safari.html)
	- 4.2  David Hyatt, [An Overview of WebCore](http://weblogs.mozillazine.org/hyatt/WebCore/chapter2.html)
	- 4.3  David Hyatt, [WebCore Rendering](http://webkit.org/blog/114/)
	- 4.4  David Hyatt, [The FOUC Problem](http://webkit.org/blog/66/the-fouc-problem/)

5. W3C 规范<a id="res5"></a>
	- 5.1  [HTML 4.01 规范](http://www.w3.org/TR/html4/)
	- 5.2  [W3C HTML5 规范](http://dev.w3.org/html5/spec/Overview.html)
	- 5.3  [ CSS 2.1规范](http://www.w3.org/TR/CSS2/)

6. 浏览器构建说明<a id="res6"></a>
	- 6.1  Firefox. https://developer.mozilla.org/en/Build_Documentation
	- 6.2  WebKit. http://webkit.org/building/build.html